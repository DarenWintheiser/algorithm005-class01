

# 刷题方法论

 

精通一个领域：

- Chunk it up 切碎知识点： 庖丁解牛，脉络连接。画脑图。
- Deliberate      Practicing 刻意练习
- Feedback 反馈

 

## Chunk it up 切碎知识点

![Machine generated alternative text: Chunk it up  ElonMuskOfficiaI 56k points a years ago  I do kinda feel like my head is full! My context switching penalty is high and my process isolation is not What it used to  be.  Frankly, though, I think most people can learn a lot m  trying.  One bit of advice: it is important to view knowledge as s  they think they can. They sell themselves short without  make sure you understand the  f a semantic  fundamental principles, ie the trunk and big branches, before you get into the leaves/details or there is nothing for  them to hang on to.  Give Award Share Report Save ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/2452B03D-C5B1-AF4B-B9B7-2ED535A29E2C.png)

伊隆马斯克：

任何知识体系都是一棵树，把知识变成一棵树状结构，每个知识点要和你熟悉的知识挂靠在一起。

人脑不适合记忆和理解孤立的知识。

 

要达到职业化的话，就要进行每一个区域的刻意练习。

 

为方便区分，将数据结构分为：一维数据结构，二维数据结构，特殊数据结构。

![Machine generated alternative text: (string), linked list  • queue, doqua. set, map (hash or map), etc  • tEtraa. Z graph  • binary search tree (red-black tree, AVL), heap, disjoint set, Trie, etc  • Bitwise, BloomFilter  • LRLJ cache ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/D06CA408-A8EA-4A47-9D6F-82FA4657ED03.png)

 

![• If-else, switch branch  • for, while bop —-> Iteration  • Recursion (Divide & Conquer, Backtrace)  • Search: Depth first search, Breadth first search, A', etc  • Dynamic Programming  Binary Search  • Greedy  . Math Geometry ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/0C57F3E7-B3F7-4B49-9803-B862C6D125DB.png)

？复杂的算法，就是找它的重复单元是什么？？

？算法思想，代码模板？

作业：自己动手把上面的知识点绘制成脑图。

（原因：因为只有当自己动手练习，把这些各个知识点放在脑图里面。这样一个知识体系才会慢慢融为自己的东西。才能够自己把它理解和系统化。）

 

## Deliberate Practicing 刻意练习

要达到顶尖水平的话，最关键的就是基本功 - 内功。

![职 业 化 运 动  · 基 本 功 是 区 别 业 余 和 职 业 选 手 的 根 本  · 基 础 动 作 的 分 解 训 练 和 反 复 练 习 一 > 最 大 的 误 区  · 乒 乓 球  ． 台 球  · 滑 雪 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/224A4960-D933-D846-BA53-1D3305C081CC.png)

 

> *练习和切题的最大误区：算法题只做一遍。*

乒乓球、滑雪、算法题：只做一遍，没法熟练，没法把它变成自己的一个条件反射的动作。

 

![Deliberate Practicing  · 刻 意 练 习 一 过 谝 数 （ 五 毒 神 掌 〕  · 练 习 缺 陷 、 弱 点 地 方  · 不 舒 服 、 不 爽 、 枯 燥  · 生 活 中 例 子 ： 乒 乓 球 、 台 球 、 游 戏 等 等 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/218CA6F2-2396-A043-84E6-6D8AA77500FA.png)

如何用刻意练习的方式进行算法训练？关键字：过遍数。

跟准备托福背单词是差不多，就是要过遍数。

这里可以明确一个量化指标：**五遍刷题法（五毒神掌）**，后面会详细讲五遍刷题具体方法。

 

练习自己的弱项，实力上缺陷的地方。

练习的时候觉得不舒服不爽和枯燥，有这样的感觉其实就对了。这样的感觉就是自己在成长了。就像在健身房练习某些动作确实让人不舒服，但是就会长肌肉。

当你一个地方练习的很好，很有信心的时候，这一点就会成为你的舒适区。要提高的话，一只脚要踏在舒适区之外，把自己的弱项进行反复练习，过一段时间的强化之后，就会发现突破了自己的弱项。

对于递归和动态规划，一碰到就犯糊涂，那么就逼自己反复地练习这些类型，经过10个20个上百道题的动态规划练习之后，都可以达到很熟练的水平。

乒乓球队训练小队员：大量的反复练习基本动作才能让基本功变好，

 

## Feedback 反馈

![Feedback  ． 即 时 反 馈  · 主 动 型 反 馈 （ 自 己 去 找 ）  · 高 手 代 码 (GitHub, Lee ℃ Ode, etc.)  ． 第 一 视 角 直  ． 被 动 式 反 馈 （ 高 手 给 亻 旨 点 ）  · code review  ． 教 练 看 你 打 ， 给 你 反 馈 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/E685D5B0-BAFD-1D45-9D58-6A3393D85369.png)

 

## 刷题技巧（五遍刷题法）

对于单个题目，在做任何题目前养成习惯：四步系统化的思考方式 （切题四件套）

![• Clarification  • Possible solutions  • compare (time/space)  • optimal (DE)  • Coding (3%)  • Test cases ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/C7C5315E-278A-F74D-8085-85B1507E1A24.png)

 

五遍刷题法： 任何题目至少做5遍。

![刷 题 第 一 遍  · 5 分 钟 ： 读 题 + 思 考  · 直 接 看 解 法 ： 注 意 ！ 多 解 法 ， 比 较 解 法 优 劣  · 背 诵 、 默 写 好 的 解 法 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/AAFF98C0-C0E6-2345-8B95-FE4C192E2BEC.png)

5-10分钟，最多15分钟，读题思考可能的解法。

如果15分钟想不出，直接看答案。不要花太多的时间。

**关键**：背诵答案，并默写。能背出来说明真理解了。

第一遍，直接看解法，背诵默写好的解法。

 

![刷 题 第 二 遍  · 马 上 自 己 写 一 > Lee ℃ ode 提 交  · 多 种 解 法 比 较 、 体 会 一 > 优 化 ！  7 小 时  法 行 出  巧 出  巧 用 距  33 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/6D66FB8B-7E15-F841-B3FF-3948AD5A12BD.png)

第二遍，马上自己写。对leetcode的运行结果进去debug和优化，比较不同解法优劣。

 

![刷 题 第 三 遍  · 过 了 一 天 后 ， 再 重 复 做 题  · 不 同 解 法 的 熟 练 程 度 一 > 专 项 练 习 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/C94926FA-2176-FD48-A2C4-58F3743BB8B4.png)

第三遍，24小时后，再做一次相同的题目，对于比较难写的解法，要进行专项练习。

 

![刷 题 第 四 遍  · 过 了 一 周 ： 反 复 回 来 练 习 相 同 题 目 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/82ECC77E-80A7-4E42-9AC6-86B37CFC14C0.png)

第四遍，一周之后，再做一次题目，对于难写的解法，进行专项练习。

 

前四遍完成后，一般的学员可以对这一类题目比较熟练了。

 

![刷 题 第 五 遍  · 面 试 前 一 周 恢 复 性 训 练 ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/39926874-3937-F04F-97E2-188216E1FCE9.png)

第五遍，面试前的恢复性训练。按面试的情况，可以提前两周或者半周按自己时间安排。

 

![小 结  · 职 业 训 练 ： 拆 分 知 识 点 、 刻 意 练 习 、 反 馈  · 五 步 刷 题 法 （ 五 毒 神 掌 ）  · 做 算 法 题 的 最 大 误 区 ： 只 做 一 遍 ， ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/09F55153-F4B5-F240-A500-91AEBC0EDC14.png)

目标：反复练习，直到形成肌肉记忆。一看到题目，就马上想到方法一，方法二是什么，然后马上把代码模板写出来。

 

 

# 编码技巧 - 指法和小操作

home, end 行头行尾

去到行头行尾：mac: command + left/right win: Fn+left/right

光标按单词切分：option+left/right    control + left/right

删除单词： option+delete/backspace  Ctrl+Delete/Backspace

选整个行：shift+command+right/left    shift+Fn+right/left  shift+Home/End

 

# 自底向下的编程方式

代码写得非常快，非常溜。

Use **newspaper metapher**

现代代码的写作方式，就是类似于报纸的写作方式： 头版头条在最前面，然后后面才是细节。写代码像写新闻稿一样，最关键的字最大的字在标题就提现；代码上，最关键的函数写在最上面，其他的私有函数和一些细节逻辑的函数就用子函数，子函数就是在文件或者类的下面放。这一点跟老式的C/C++不一样，它们要将子函数写在文件的最上面，而现代的语言，函数放什么位置都可以。

 

- [自顶向下的编程方式](http://markhneedham.com/blog/2008/09/15/clean-code-book-review/)
- [自顶向下编程的      LeetCode 例题](http://leetcode-cn.com/problems/valid-palindrome/)

 

From <https://u.geekbang.org/lesson/2?article=171643> 

 

例如回文串的题目：

![public boolean s) {  // 1. filter out number & 2. reverse and compare  _fi IterNomaumberAndCha  String filteredS =  String reversedS = _ revdksestring(fittereds);  return  private String _ reverseString(String {  return null;  private String _ filte rNonNumberAndChar(String  return null; ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/8BC04100-836E-844F-A8FB-B9041338AA07.png)

 

使用自顶向下的方法去写工程类的代码会很方便，工程类代码的业务逻辑相对比较繁复，算法部分比较少，所以用这种自顶向下的方法可以比较容易地写出主要逻辑的部分，对应截图里面的几个主要函数。

然后就是代码填空：

![public boolean s) {  // I. filter Out number 2. reverse and compare  _ filterNorWumberAndChar(s)  String filteredS =  return _reverseString(filteredS) .equalsIgnoreCase(filteredS) :  private String _ reverseString(String s) {  return new Stringauilder(s) . reverse() .toString();  private String _fi1terNonNumberAndChar(String s) {  return s. replaceALI( regex: " replacement: ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/51D287D7-3D9C-374A-AB71-CE93E82476AD.png)

 

# 七种常见时间复杂度

![Big O notation  0(1): Constant Complexity  O(log n): Logarithmic Complexity  O(n): Linear Complexity  O(nA2): N square Complexity  O(nA3): N square Complexity  O(2An): Exponential Growth  Factorial ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/BD223E74-E03D-1549-920F-175C4526D480.png)

记住主要算法的时间复杂度。

？

![Big O notation  O(log(n))  0(kAn)  for (int i -1  - I'm busy looking at: '  int fib(int n) {  if (n 2) return n;  return fib(n - 1) + fib(n - 2); ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/114BAAD1-BA97-BA4E-A8EB-FC464BF306E9.png)

 

简单的递归方式求斐波那契数列，时间复杂度是指数级的O(2^n)，非常慢。

![int fib(int n) {  if (n 2) return n;  return fib(n - 1) + fib(n - 2); ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/69A8787E-CF97-4443-A140-9030B53E981B.png)

 

![Fib(6)  f(3) ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/EB67F142-7604-E94A-B460-F8922D8A64F3.png)

 

主定理：

![Application to common algorithms  1 00)  cpiira  Ng M"ter e =  M"ter e =  = logto) ](file:////Users/zhangdingsong/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/A97FAB6B-E120-2847-A3CE-EE10FEC4DF59.png)

二分查找复杂度 O(log n)

二叉搜索树： O(n) 树形结构，每个节点只访问一次，且仅访问一次。

有序矩阵查找： O(n) 一维变二维，一维数组进行二分查找的复杂度O(log n), 降维成二维后，复杂度变低 O(n) 记住！！

归并查找： 所有查找里时间复杂度最低的归并查找，O(nlogn)

 

二叉树遍历：前中后。O(n) 因为二叉树的每个节点访问一次，且仅访问一次

图的遍历，O(n) 原理同二叉树遍历，节点只访问一次

搜索算法： DFS, BFS. O(n) 访问的节点只访问一次。n指搜索空间里的节点总数

 

如何理解算法时间复杂度的表示法

https://www.zhihu.com/question/21387264