## 链表**：**

> ​    链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。叫作**后继指针 next**。

![img](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)



+ 链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。



![img](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)

![img](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)



####单向列表没意义

先来看删除操作。在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

- 删除结点中“值等于某个给定值”的结点；
- 删除给定指针指向的结点。

查找部分：不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。



对于一个有序链表，**双向链表**的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，**所以平均只需要查找一半的数据**

#### LinkedHashMap 的实现原理

就会发现其中就用到了双向链表这种数据结构。

![img](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)



----



#### ArrayList 容器

支持动态扩容，大于max，自动扩大1.5倍

除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

----



####如何基于链表实现 LRU 缓存淘汰算法？



我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 若存在，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 若不存在，又可以分为两种情况：
   - 缓存未满，则将此结点直接插入到链表的头部；
   - 缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

因为不管缓存有没有满，我们都需要**遍历一遍链表**，所以这种基于链表的实现思路，缓存访问的时间复杂度为 **O(n**)。

可以继续优化这个实现思路，比如引入**散列表（Hash table）**来记录**每个数据的位置**，将缓存访问的时间复杂度降到 O(1)。



---

### 写好链表的五个技巧

1. **理解指针或引用的含义**， 存储所指对象的内存地址。
   - c:指针
   - java,python:没有指针概念，都是引用概念

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

2. **警惕指针丢失和内存泄漏**

我们插入结点时，例，新增x,插入a和b之间，一定要**注意操作的顺序**，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。

**删除链表结点时，也一定要记得手动释放内存空间**

3. **利用哨兵简化实现难度**

```c
new_node->next = p->next;

p->next = new_node;

//对于头
if (head == null) { head = new_node;}

//删除
p->next = p->next->next;
//对于尾部
if (head->next == null) { head = null;}
```

哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。

我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。

![img](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

4. **重点留意边界条件处理**

我经常用来检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

5. **举例画图，辅助思考**

----

实现代码

- 单链表反转
- 链表中环的检测 。 快指针 慢指针
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点





**p ：二级指针，表示p所指向的地址里面存放的是一个指向类型的指针。

*p：一级指针，表示p所指向的地址里面存放的是一个类型的值。