学习笔记


## 学习总结

## leetcode刷题记录

### https://leetcode-cn.com/problems/number-of-1-bits/ 191. 位1的个数

n的位数是32位. 使用for循环 从0到32迭代. 每次迭代将1从0位向高位移动. 然后和n取& 看是否等于0  不等于0 count++

最后输出count

1 & 1 = 1; 1&0=0; 0&1=0; 0&0 = 0;

### https://leetcode-cn.com/problems/power-of-two/ 231. 2的幂

判断n是否为2的次幂.  首先n必须大于0. 并且 n 和 n-1 去&运算 如果==0 说明就是2的次幂;

例如 2^2 = 4 = 0100   n-1 = 3 = 0011 ; 0100 & 0011 = 0000;


### https://leetcode-cn.com/problems/reverse-bits/ 190. 颠倒二进制位

2进制数 1101   int是32位. 这里只会写出低位4位. 高位全是零. 我们希望得到一个1101后面跟着28个0的二进制数
0000000000000000000000000001101 -> 1101000000000000000000000000000

int result = 0;

i = 0 

0000000000000000000000000001101 >> 0 = 0000000000000000000000000001101;

0000000000000000000000000001101 & 1 = 1; temp = 1

temp = temp << (31 -i); temp = 1000000000000000000000000000000;

result = result | temp;  保留高位1;1000000000000000000000000000000 | 0000000000000000000000000000000 = 1000000000000000000000000000000;


i = 1 

0000000000000000000000000001101 >> 1 =  0000000000000000000000000000110;

0000000000000000000000000000110 & 1 = 0; temp =0;

temp = temp << (31 -i); temp = 0000000000000000000000000000000

result = result | temp; 1000000000000000000000000000000 | 0000000000000000000000000000000 = 1000000000000000000000000000000;

n =2; 依次力推


### https://leetcode-cn.com/problems/counting-bits/description/ 338. 比特位计数

动态规划+1个数统计


### https://leetcode-cn.com/problems/lru-cache/ 146. LRU缓存机制

hash表的作用是 o(1)的时间负责度, 可以知道cache中是否存在. 
双向链表head和tail. 作为cache. 当添加node进入cache时. 验证cache中是否存在. 存在.删除原有的. 将node添加到head.  没见过时比较cache大小是否超过limit. 超过tail删除一个. 否在直接添加到head, 并添加到hash.