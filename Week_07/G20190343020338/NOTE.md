#学习笔记
## 第7周-第16课 | 位运算
### 1. 位运算基础及实战要点
> * 1. 位运算符
> * 2. 算数位移与逻辑位移
> * 3. 位运算的应用
> * 为什么需要位运算以及位运算它本质上是什么
> * 位运算的由来其实很简单，就是因为在计算机里面数字的表示形式不是人类常用的熟悉的十进制。人们为什么熟悉十进制，是因为历史的原因以及人类的大脑构造，觉得十进制更加好用，为什么呢？因为我们的手指是有十个，所以在古代人们计数的时候，用手指更好数。那么计算机的话因为大部分都是高电位和低电位，所以就010101。它本身任何的一个整型或者是十进制的数，在计算机里面的数字表示方式和存储形式都是二进制，大一的时候学计算机原理的时候讲过。如果给你一个十进制的数要把它转换成二进制应该怎么转换。给你任何一个十进制数，怎么把它转换成二进制数。或者是任何一个二进制数怎么把它转回十进制数。
> * 要求二进制的表示形式就不断地除以2，把模出来的余数写在后面，一步一步写下来之后，最开始除以2得到的余数是它的最低位，越到后面说明位数越高，所以把所有的余数从下到上把它列出来，就等于它的二进制位了。
> * 如何把二进制转换为十进制呢？从最底下的余数开始，按顺加上余数的二次方得到十进制数。
> * 位运算符
> * 位运算经常会有左移和右移，他们分别有逻辑左移和标准的计算机的左移。
> * 计算机里面的左移是什么？
> * 比如0011，把它左移一位，那就是把这个数字，整串二进制符号往左移一位。同时，空出来的二进制位补0。如果要左移的0一出去之后位就没有了，不管这个位是0是1移出去之后就没有了。右移同理可得，就把这一串数字往右移一位就行了，这边新的位数始终是补0的，老的位数一出去就去掉。
> * 在计算机里面的话，一般来说老式的计算机是32位的，新的计算机，就比如现在买的笔记本，基本上都是64位的，所以它的一个整型其实就是有64个二进制位表示。
> * 四种常用的位运算符；
> * 1. | 按位或运算：或必须是两个二进制数进行操作，或指的是只要有一个二进制位是1，那么或出来的结果就是1。
> * 2. & 按位与运算：与或相反，只要有一个二进制位是0，那么与出来就是0。
> * 3. ~ 按位去反：把0011变成1100。
> * 4. ^ 按位异或：表示如果相异的话就是1，如果相同的话就是0。
> * XOR-异或
> * 异或：相同的为0，不同的为1。也可以用“不进位加法”来理解。
> *异或操作的一些特点：（稍微高阶一点的，记住就好了）
> * x ^ 0 = x：只要x和0相同的，那就是0，不同的就是1。那x异或0就是x本身。
> * x ^ 1s = ~x //注意1s = ~0：x异或全1，这里的1s指的是全1，全1的话就是0取反，这里的话就是全0。x异或全0就等于x，x异或全1就等于x取反，就是把x里面所有的位0变1，1变成0。
> * x ^ (~x) = 1s：那么同理x如果异或x取反的话，1变成0了。那么同理x如果异或x取反的话，x取反的话就是所有的二进制位0变成了1，1变成了0。它和x的话，所有的二进制位都是不同的，那么异出来的结果就是全1。
> * x ^ x = 0：x异或x它们的所有二进制位，这两者所有的二进制位都是相同的，那么相同就是0。
> * c = a ^ a => a ^ c = b ,b ^ c = a //交换两个数
> * a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c //associative
> * 同时可以用来交换两个数，以及有所谓的结合法，后面两者用得比较少。了解下即可。
> * 经常我们在操作一个数它的位运算的时候，需要对这个数某几个二进制位进行置1的操作或者是清零的操作，或者是将它的指定的二进制位挪动，那么我们在程序里面经常会用到这么几个事情。
> * 指定位置的位运算
> * 1. 将x最右边的n位清零：x & (~0 << n)，就是把要做的一个事情，把0取反了之后就全部都是1，全部都是1之后向左位移了n位之后。，变成111111...，最后的话有n个0。和x与在一起指的是，将x的右边n位全部清零，只留下最左边的那些高位。右边低位的n全部都是清零的。
> * 2. 获取x的第n位值（0或者1）：（x >> n） & 1，就是把x先右移n次，那么x第n位就变成最后一位了，然后再与上一个1，就得到了第n位是到底是0还是1。
> * 3. 获取x的第n位的幂值：x & (1 << (n - 1))，同理可得，就是把一个1往左移移到高位去，然后和x与一下。 
> * 4. 仅将第n位置为1：x | (1 << n)。
> * 5. 仅将第n位置为0：x & (~ (1 << n))。
> * 6. 将x最高位至第n为（含）清零：x & ((1 << n ) - 1)。
> * 7. 将第n位至第0位（含）清零：x & (~ (1 << (n + 1) ) - 1)。
> * 以上都是同理可得的，如果是第一次见的话，要好好想一想，然后在纸上把他们画出来。
> * 实战位运算要点 （面试的时候位运算讲的最多的，不管是在布隆过滤器、还是在N皇后问题讲的最多的，用的最多的就是这样一些位运算的技巧）
> * 判断奇偶：
> * x % 2 == 1 -> (x & 1) == 1， x % 2 == 0 -> (x & 1) == 0 
> * 经常会用的一个操作就是x模上2，到底是否等于1。也就是x除以的余数到底是0还是1，这个是数学上或者是从小到大学习数学的时候它的定义。但在计算机领域，更快捷的一个操作就是x与1，直接用x与1看看它是否等于1就行了也就是判断它的二进制位最后一位到底是0还是1，是0的话就说明是偶数，是1的话就表示是奇数。同时的话位运算比模操作要快不少，所以以后判断奇偶性，能用位运算就用位运算，那么始终用这个来写就行了。当然用Java或者是其它高级语言，用模的形式，它的编译器足够智能，肯定也是转换成二进制的，它不会傻傻地去模的。
> * x >> 1 -> x / 2 即：x = x / 2; -> x = x >> 1;
> * 相当于把它的最后一位二进制位清空，然后整个树再往右挪一步，那就相当于它除了2，也就是x除2这个操作，就可以用x右移一位来表示，所以以后写代码x = x / 2，就直接x = x 向右移一位是一样的，而且这样的话更快。
> * mid = (left + right) / 2; -> mid = (left + right) >> 1;
> * 在做二分查找的话，经常用的一个操作就是，左边界再加右边界再除以2。就可以用左边界再加右边界加在一起，右移一位来表示。
> * x = x & (x - 1)，表示清零最低位的1，在纸上自己画下，就直接比如说x = 01101000，然后把x - 1 列出来到底是多少，然后再把两者与一下。这个时候会发现操作做的一件事情就是把x的最低位的二进制1给去掉了。
> * x & -x => 得到最低位的1所表示的整个数。
> * x & ~x => 0。

## 第7周-第17课 | 布隆过滤器和LRU缓存
### 1. 布隆过滤器的实现及应用
> * 两个比较高级的数据结构，而且它们在面试中，以及在工业级的应用上面都较为广泛。
> * 布隆过滤器 Bloom Filter
> * HashTable + 拉链存储重复元素
> * 布隆过滤器它是和哈希表类似，很多时候我们经常把它去和哈希表进行对比。哈希表如果有重复的元素，采用拉链存储法的话，可以看到本身任何一个元素进来，会经过一个哈希函数。
> * 假设进来的就是一个String，它经过一个哈希函数之后，就映射到一个整数的下标位置，叫整数的index。比如说Lisa Smith的字符串就映射到001，然后存在001这位置，然后她的电话就是123456。当两个字符串被哈希到了同一个位置，那么所采用的解决冲突的办法就是在这个位置开一个链表，把多个元素都存在相同的位置的链表处，往后面不断积累，它就是哈希表一种存储形式。
> * 这里发现一个特点，就是对于哈希表，它不仅有哈希函数来得到这么一个index值，且它会把整个要存的元素全部都放在哈希表里面去。这是一个没有误差的数据结构，且有多少的元素，每个元素有多大，那么所有的这些元素需要占的内存空间，在哈希表里面都要找相应的内存的大小给存进来。
> * 在很多时候在工业级应用的时候发现我们并不需要存所有的元素本身，而只需要存一个信息，就是这个元素在这个表里面到底是有还是没有。
> * 在这种情况下的话，如果只要查询有还是没有的时候，这个时候就需要一种更高效的数据结构。这个更高效的数据结构可以导致的一个结果，就是这里面有很多元素要存，但是这个表所需要的内存空间很少，同时我们不需要把元素本身，就比如不要把它String这些东西全部存起来，只需要说这个东西到底是有还是没有。
> * 这种数据结构是怎么设计出来的？一个叫Bloom Filter应运而生。
> * Bloom Filter vs Hash Table 
> * 布隆过滤器它是一个很长的二进制向量 和 一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
> * 所以它和哈希表一个最大的区别：
> * 哈希表不仅可以判断它是否在集合中，也就是说哈希表的话就是map，我们在用map的时候，不仅可以判断它是否在其中，而且可以再存很多冗余的信息，比如说可以存他的电话号码存在这个哈希表当中，所以哈希表的话不止是判断是否在集合，同时还可以存元素本身和元素对应的各种额外信息。
> * 布隆过滤器的话只是用于检索一个元素是否在还是不在，它只能存在和不在的信息，而不能存其他额外的信息。
> * 它的优点就是空间效率和查询时间都远远高于一般算法，为什么能达到这个，它是用了二进制向量来表示，所以它很节省空间。另外一个方面它是一种模糊的查询方式。
> * 它的缺点就是有一定的误识别率和删除困难这个两个。
> * 布隆过滤器的整个原理
> * 对于任何一个元素，假设要存三个元素{x,y,z}依次存进来，这里的x,y,z不是同事往里面灌，是一个一个依次往里面灌。每一个元素它会分配到一系列的二进制位中。假设x它就分配到三个二进制位，那么x插入到布隆过滤器就表示把x对应的这三个位置置为1就可以了，那么接下来y插入进来，那么y根据它的哈希函数，就分为另外三个对应的二进制位也置为1，同理z的话也分成三个就置为1。这个二进制的数组就用来表示所有的已经存入的xyz，是否已经在索引里面了。这个时候重新给你一个元素x，就会始终对应于这个三个二进制位，那么去这个表里面查，就查到这三个皆为1，所以话可以认为x是存在的。
> * 如有一个陌生的元素w进来之后，它把它分配给通过布隆过滤器的二进制索引的函数，w就也会得到三个二进制位，这三个二进制位是110，有一个二进制位为0说明什么呢？说明w未在索引里面。这个时候会发现一个特点，如果一个元素它所对应的二进制位，只要有一个为0，就说明这个元素不在布隆过滤器的索引里面，且我们是可以肯定它不在的。
> * 但是当一个新的元素比如q，它刚好分配的三个二进制位都为1的话，我们不一定能说是在的。
> * 结论：当布隆过滤器把元素全部都插入完了之后，对于测试元素，也就是新来的一个元素，要来验证它是否存在的话，当它验证这个元素所对应的二进制位是1的时候，我们只能说它可能存在在布隆过滤器里面。但是当这个元素所对应的二进制位只要有一个不为1，那么我们可以百分之一百肯定它不在。
> * 也就是说千言万语汇成一句话，这个元素去布隆过滤器里面查，如果查到它不在的话，那么它肯定就是不在的，如果查这个元素查到布隆过滤器里面它的二进制位都是1，为存在的一个状态的话，那么我们只能说它可能存在的。
> * 那么当这种元素在里面查到的时候，那么接下来要怎么判断它到底是否存在呢？布隆过滤器只是放在最外面来当一个缓存使用的，也就是说来当一个很快的判断标准使的，当这种情况的元素查到布隆过滤器里面是存在的，那么这个元素就会继续放在数据库里面去查，到时候的话会查出来这个元素是不存在的。如果在布隆过滤器查到这个元素不存在，就不用在放在数据库里面继续查了，它肯定是不存在了，这样就节省下来访问数据库的时间了，而且可以肯定这个元素肯定也未添加进数据库里面。
> * 这个时候会发现布隆过滤器，只是挡在一台机器前面的快速查询的缓存，真真要确定元素一定存在的话，它必须在访问这个机器里面的一个完整的存储数据结构，在工业上应用的话，一般来说也就是数据库了。
> * 现实中的应用案例
> * 1. 比特币网路，因为比特币是分布式系统，所以在分布式系统中，一个地址是否在这个结点里面，以及这个tansaction是否在node里面，经常会要用到所谓的布隆过滤器来进行快速查询。
> * 2. 分布式系统（Map-Reduce、Hadoop、search engine之类的），以及Google用得很多这样的，比如说搜索引擎经常做的很多事情，就是把大量的网页信息，还有图片信息都存在它的整个服务器里面。